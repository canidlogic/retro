/*
 * retro_compile.c
 * ===============
 * 
 * Retro synthesizer compiler.
 * 
 * Syntax
 * ------
 * 
 *   retro_compile [options] < performance.script > opl.script
 * 
 * Options
 * -------
 * 
 *   -stage [path]
 * 
 * Define the OPL2 register configuration used to set the stage.  This
 * is a register definition in the same format that is generated by the
 * retro_stage program.  Required option.
 * 
 *   -wait [integer]
 * 
 * After setting the stage at the first control cycle, wait this many
 * cycles before beginning the performance.  The integer must be an
 * unsigned decimal integer zero or greater, with zero meaning no delay
 * between finishing the stage and starting the performance.  Optional;
 * default value is zero.
 * 
 * Description
 * -----------
 * 
 * Compiles a Retro performance script into an OPL2 register script.
 * See separate documentation for the format of the Retro performance
 * script.
 * 
 * Dependencies
 * ------------
 * 
 * The following Retro modules are required:
 * 
 *   - diagnostic.c
 */

#include <ctype.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "diagnostic.h"

/*
 * Diagnostics
 * ===========
 */

static void raiseErr(int lnum, const char *pDetail, ...) {
  va_list ap;
  va_start(ap, pDetail);
  diagnostic_global(1, __FILE__, lnum, pDetail, ap);
  va_end(ap);
}

static void sayWarn(int lnum, const char *pDetail, ...) {
  va_list ap;
  va_start(ap, pDetail);
  diagnostic_global(0, __FILE__, lnum, pDetail, ap);
  va_end(ap);
}

/*
 * Constants
 * =========
 */

/*
 * Size of m_lnum_buf.
 *
 * Must be big enough to hold the string "<unknown>" with a terminating
 * nul byte.  Should be big enough to hold the decimal representation of
 * the largest int32_t value.
 */
#define LNUM_BUF_LEN (32)

/*
 * Size of m_line_buf.
 * 
 * This is the buffer that is used to read input lines from the input
 * file.
 */
#define LINE_BUF_LEN (256)

/*
 * The length in characters of a frequency-format code.
 */
#define FREQF_LEN (5)

/*
 * The initial and maximum capacity of the event table, measured in
 * events.
 * 
 * The event table starts with the initial capacity.  It then grows by
 * doubling up to the maximum capacity.
 */
#define EVENT_INIT_CAP INT32_C(256)
#define EVENT_MAX_CAP INT32_C(1048576)

/*
 * Type declarations
 * =================
 */

/*
 * Structure representing a performance event.
 */
typedef struct {
  
  /*
   * The time offset of the event.
   */
  int32_t t;
  
  /*
   * The duration of the event.
   * 
   * Null events have a duration of zero.  All other events have a
   * duration of at least two.
   */
  int32_t dur;
  
  /*
   * The frequency of the event.
   * 
   * Null events, and hi-hat and cymbal events have a frequency of -1.
   * 
   * Melodic events, and bass drum, snare drum, and tom-tom have a
   * frequency in the format returned by the function parseFreqF().
   */
  int16_t freq;
  
  /*
   * The channel of the event.
   * 
   * Null events have a channel of -1.
   * 
   * Melodic events have a channel of 1-9.  Only channels 1-6 can be
   * used if rhythm section is enabled.
   * 
   * Bass drum, snare drum, and tom-tom have a channel of 20, 21, 22.
   * Only allowed if rhythm section is enabled.
   * 
   * Hi-hat and cymbal have a channel of 31, 32.  Only allowed if rhythm
   * section is enabled.
   */
  int8_t ch;
  
} EVENT;

/*
 * Local data
 * ==========
 */

/*
 * Buffer for storing line number output for lineString().
 */
static char m_lnum_buf[LNUM_BUF_LEN];

/*
 * Buffer for storing lines from readLine().
 */
static char m_line_buf[LINE_BUF_LEN];

/*
 * The OPL2 register stage.
 * 
 * The index of this array is the register number of the OPL2.  The
 * values are the 8-bit register values in range 0 to 255 (inclusive),
 * or the special value -1 indicating the register index is not part of
 * the stage.
 * 
 * m_stage_init indicates whether the register stage has been
 * initialized.
 */
static int m_stage_init = 0;
static int16_t m_stage[256];

/*
 * The parameters read from the header of the performance file.
 * 
 * m_head_init indicates whether these are initialized.
 */
static int m_head_init = 0;
static int m_head_rate = 0;
static int m_head_rhythm = 0;
static int m_head_b_def = 0;
static int m_head_s_def = 0;
static int m_head_t_def = 0;

/*
 * The event table.
 * 
 * m_ev_cap is the current capacity of the table.  If zero, then the
 * table is not initialized.
 * 
 * m_ev_count is the number of events in the table actually in use.
 * 
 * m_ev is a pointer to the event table, or NULL if the capacity is
 * zero.
 */
static int32_t m_ev_cap = 0;
static int32_t m_ev_count = 0;
static EVENT *m_ev = NULL;

/*
 * Sequencer state information.
 * 
 * m_st_init indicates whether state is initialized.
 * 
 * m_st_t stores the current time offset within the performance.
 * 
 * m_st_wta is the "wait array."  The nine melodic channels occupy
 * indices 0-8.  Bass drum is index 9.  Snare drum 10.  Tom-tom 11.
 * Hi-hat 12.  Cymbal 13.  When initialized, -1 in a index means nothing
 * is currently active.  Otherwise, the value is a time index that
 * indicates when an active event should be released.
 * 
 * m_st_reg is the "register array."  The nine melodic channels occupy
 * indices 0-8.  The tenth channel is the percussion register.  When
 * initialized, each element is an unsigned byte value that stores the
 * current value of the 0xB0-0xB8 registers (for melodic channels) and
 * the current value of the 0xBD register (for percussion control).
 */
static int m_st_init = 0;
static int32_t m_st_t = 0;
static int32_t m_st_wta[14];
static int m_st_reg[10];

/*
 * Local functions
 * ===============
 */

/* Prototypes */
static int32_t parseInt(const char *pStr);

static int readChar(FILE *pIn);
static const char *readLine(FILE *pIn);
static int isLWS(int c);
static int b16Digit(int c);

static void loadStage(const char *pPath);

static const char *lineString(int32_t input_line);

static int parseFreqF(const char *pStr, int32_t lnum);
static void parseMatch(
    const char    * pStr,
    const char    * pMatch,
          int32_t   lnum);
static int parseAlphanum(const char *pStr, int32_t lnum);
static int32_t parseGap(const char *pStr, int32_t lnum);
static int32_t parseDecimal(
    const char    * pStr,
          int32_t * pVal,
          int32_t   lnum);

static int remBlank(const char *pStr);

static int cmpEvent(const void *pA, const void *pB);
static void addEvent(const EVENT *pe);
static void readHeader(FILE *pIn);
static void parseLine(const char *pStr, int32_t lnum);

static void releaseRegisters(int32_t max_t);
static void beginNote(int ch, int freq, int32_t dur);

/*
 * Parse a program argument as an unsigned decimal integer.
 * 
 * Parameters:
 * 
 *   pStr - the string to parse
 * 
 * Return:
 * 
 *   the numeric value
 */
static int32_t parseInt(const char *pStr) {
  
  int32_t result = 0;
  int c = 0;
  
  /* Check parameter */
  if (pStr == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Check that string not empty */
  if (*pStr == 0) {
    raiseErr(__LINE__, "Not a valid integer argument");
  }
  
  /* Parse string */
  for( ; *pStr != 0; pStr++) {
    /* Get character */
    c = *pStr;
    
    /* Get numeric value */
    if ((c >= '0') && (c <= '9')) {
      c = c - '0';
    } else {
      raiseErr(__LINE__, "Not a valid integer argument");
    }
    
    /* Multiply result by 10, watching for overflow */
    if (result <= INT32_MAX / 10) {
      result *= 10;
    } else {
      raiseErr(__LINE__, "Integer argument is too large");
    }
    
    /* Add digit to result, watching for overflow */
    if (result <= INT32_MAX - ((int32_t) c)) {
      result += ((int32_t) c);
    } else {
      raiseErr(__LINE__, "Integer argument is too large");
    }
  }
  
  /* Return result */
  return result;
}

/*
 * Read a character or EOF from the given file.
 * 
 * Checks for and filters out I/O errors.
 * 
 * Parameters:
 * 
 *   pIn - the file to read from
 * 
 * Return:
 * 
 *   the character read in range 0 to 255 (inclusive), or -1 if EOF
 */
static int readChar(FILE *pIn) {
  
  int c = 0;
  
  if (pIn == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  c = fgetc(pIn);
  if (c == EOF) {
    if (feof(pIn)) {
      c = -1;
    } else {
      raiseErr(__LINE__, "I/O error");
    }
  }
  
  return c;
}

/*
 * Read a whole line from the given file.
 * 
 * If there is no more data in the file, NULL is returned.  Otherwise,
 * the return value will point to the nul-terminated line that was read.
 * 
 * The returned buffer is statically allocated and overwritten with each
 * call to this function.
 * 
 * The returned line will not include any line break at the end.
 * 
 * Any characters outside of ASCII range [0, 127] will be replaced with
 * character 127, and any nul characters will be replaced with 127 as
 * well.
 * 
 * Parameters:
 * 
 *   pIn - the file to read from
 * 
 * Return:
 * 
 *   the nul-terminated line that was read, or NULL if no more lines in
 *   file
 */
static const char *readLine(FILE *pIn) {
  
  int32_t written = 0;
  int c = 0;
  const char *pResult = NULL;
  
  /* Check parameters */
  if (pIn == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Clear line buffer */
  memset(m_line_buf, 0, LINE_BUF_LEN);
  
  /* Read character and only proceed if we read something besides EOF */
  c = readChar(pIn);
  if (c >= 0) {
    /* We read something, so we will return a result */
    pResult = m_line_buf;
    
    /* Process line */
    for( ; c >= 0; c = readChar(pIn)) {
      /* Handle special characters */
      if (c == '\r') {
        /* Carriage return must be followed by line feed */
        c = readChar(pIn);
        if (c != '\n') {
          raiseErr(__LINE__, "CR without LF");
        }
        
        /* Line break, so leave processing loop */
        break;
      
      } else if (c == '\n') {
        /* Line feed, so leave processing loop */
        break;
      
      } else if ((c > 127) || (c < 1)) {
        /* Non-ASCII character, so replace with 127 */
        c = 127;
      }
      
      /* Add character to line buffer, watching for overflow */
      if (written < LINE_BUF_LEN - 1) {
        m_line_buf[written] = (char) c;
        written++;
      } else {
        raiseErr(__LINE__, "Input line is too long");
      }
    }
  }
  
  /* Return result or NULL */
  return pResult;
}

/*
 * Check whether a given character is "linear whitespace."
 * 
 * The only linear whitespace characters are SP, HT, CR, and LF.
 * 
 * Parameters:
 * 
 *   c - the character to check
 * 
 * Return:
 * 
 *   non-zero if linear whitespace, zero if not
 */
static int isLWS(int c) {
  int result = 0;
  if ((c == ' ') || (c == '\t') || (c == '\r') || (c == '\n')) {
    result = 1;
  }
  return result;
}

/*
 * Decode the numeric value of a base-16 digit.
 * 
 * Parameters:
 * 
 *   c - the character to decode
 * 
 * Return:
 * 
 *   the numeric value of the base-16 digit or -1 if not a base-16 digit
 */
static int b16Digit(int c) {
  int result = -1;
  if ((c >= '0') && (c <= '9')) {
    result = c - '0';
  } else if ((c >= 'a') && (c <= 'f')) {
    result = (c - 'a') + 10;
  } else if ((c >= 'A') && (c <= 'F')) {
    result = (c - 'A') + 10;
  }
  return result;
}

/*
 * Load the stage into m_stage using the register file definition at the
 * given path.
 * 
 * Parameters:
 * 
 *   pPath - the path to the register file definition
 */
static void loadStage(const char *pPath) {
  
  int i = 0;
  int c = 0;
  int v = 0;
  FILE *pIn = NULL;
  
  /* Check parameters */
  if (pPath == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Initialize stage registers, overwriting anything currently there */
  memset(m_stage, 0, sizeof(int16_t) * 256);
  for(i = 0; i < 256; i++) {
    m_stage[i] = (int16_t) -1;
  }
  m_stage_init = 1;
  
  /* Open input file */
  pIn = fopen(pPath, "r");
  if (pIn == NULL) {
    raiseErr(__LINE__, "Failed to open input file: %s", pPath);
  }
  
  /* Read all 256 register values */
  for(i = 0; i < 256; i++) {
    /* If this is not the first register value, read at least one
     * character that is linear whitespace */
    if (i > 0) {
      c = readChar(pIn);
      if (!isLWS(c)) {
        raiseErr(__LINE__, "Invalid register stage");
      }
    }
    
    /* Skip linear whitespace until EOF or non-whitespace */
    for(c = readChar(pIn); isLWS(c); c = readChar(pIn));
    
    /* If we read a hyphen, read the second hyphen of the special "--"
     * value and then skip this register */
    if (c == '-') {
      if (readChar(pIn) != '-') {
        raiseErr(__LINE__, "Invalid register stage");
      }
      continue;
    }
    
    /* At this point, we should be at a base-16 character; decode it
     * into v */
    v = b16Digit(c);
    if (v < 0) {
      raiseErr(__LINE__, "Invalid register stage");
    }
    
    /* Read another base-16 character and combine it into v */
    c = readChar(pIn);
    c = b16Digit(c);
    if (c < 0) {
      raiseErr(__LINE__, "Invalid register stage");
    }
    v = (v << 4) | c;
    
    /* Store this register value */
    m_stage[i] = (int16_t) v;
  }
  
  /* Make sure nothing but linear whitespace remains */
  for(c = readChar(pIn); c >= 0; c = readChar(pIn)) {
    if (!isLWS(c)) {
      raiseErr(__LINE__, "Invalid register stage");
    }
  }
  
  /* Close input file */
  if (fclose(pIn)) {
    sayWarn(__LINE__, "Failed to close input file");
  }
}

/*
 * Return a string representation of an input line number, or the string
 * "<unknown>" if the given line number is not valid or the line number
 * doesn't fit in the buffer.
 * 
 * The returned string is held in a static buffer.  Each call to this
 * function overwrites the buffer.
 * 
 * Parameters:
 * 
 *   input_line - the line number
 * 
 * Return:
 * 
 *   an appropriate string representation
 */
static const char *lineString(int32_t input_line) {
  
  int retval = 0;
  
  /* Clear the memory buffer */
  memset(m_lnum_buf, 0, LNUM_BUF_LEN);
  
  /* Generate the appropriate string */
  if ((input_line > 0) && (input_line < INT32_MAX)) {
    /* Get the decimal representation */
    retval = snprintf(m_lnum_buf, LNUM_BUF_LEN, "%ld",
                (long) input_line);
    if ((retval < 0) || (retval > LNUM_BUF_LEN - 1)) {
      memset(m_lnum_buf, 0, LNUM_BUF_LEN);
      strncpy(m_lnum_buf, "<unknown>", LNUM_BUF_LEN - 1);
    }
    
  } else {
    /* Line number is out of range */
    strncpy(m_lnum_buf, "<unknown>", LNUM_BUF_LEN - 1);
  }
  
  /* Return the string in the buffer */
  return m_lnum_buf;
}

/*
 * Parse a frequency-format code.
 * 
 * The frequency-format looks like this:
 * 
 *   4-16B
 * 
 * The given pointer must point to the first character of the frequency
 * format.  The length of the format is always exactly FREQF_LEN
 * characters.
 * 
 * The return value has the F-number (the last three base-16 digits) in
 * the least significant 10 bits (range 0x000 to 0x3FF).  The ocatve
 * (the first digit) is the 3 most significant bits (range 0 to 7).
 * 
 * Parameters:
 * 
 *   pStr - the frequency-format code to decode
 * 
 *   lnum - the input line number (for diagnostic messages)
 * 
 * Return:
 * 
 *   the encoded value
 */
static int parseFreqF(const char *pStr, int32_t lnum) {
  
  int octave = 0;
  int fnum = 0;
  int i = 0;
  int c = 0;
  
  /* Check parameters */
  if (pStr == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Decode octave */
  if ((pStr[0] >= '0') && (pStr[0] <= '7')) {
    octave = pStr[0] - '0';
  } else {
    raiseErr(__LINE__, "Invalid frequency format on line %s",
              lineString(lnum));
  }
  
  /* Second character must be hyphen */
  if (pStr[1] != '-') {
    raiseErr(__LINE__, "Invalid frequency format on line %s",
              lineString(lnum));
  }
  
  /* Advance to third character */
  pStr += 2;
  
  /* Parse three base-16 digits */
  for(i = 0; i < 3; i++) {
    /* Get current character */
    c = *pStr;
    
    /* Decode as numeric digit */
    c = b16Digit(c);
    if (c < 0) {
      raiseErr(__LINE__, "Invalid frequency format on line %s",
                lineString(lnum));
    }
    
    /* Add to fnum */
    fnum = (fnum << 4) | c;
    
    /* Advance to next character */
    pStr++;
  }
  
  /* Check range of fnum */
  if (fnum > 0x3ff) {
    raiseErr(__LINE__, "Invalid frequency format on line %s",
              lineString(lnum));
  }
  
  /* Return encoded value */
  return ((octave << 10) | fnum);
}

/*
 * Check that the beginning of the given string is a case-insensitive
 * match for another string.
 * 
 * Parameters:
 * 
 *   pStr - the string to check
 * 
 *   pMatch - the substring to check for
 * 
 *   lnum - the input line number (for diagnostic messages)
 */
static void parseMatch(
    const char    * pStr,
    const char    * pMatch,
          int32_t   lnum) {
  
  int c1 = 0;
  int c2 = 0;
  
  /* Check parameters */
  if ((pStr == NULL) || (pMatch == NULL)) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Check for match */
  for( ; *pMatch != 0; pMatch++) {
    /* Get character pair */
    c1 = *pStr;
    c2 = *pMatch;
    
    /* Normalize to lowercase */
    c1 = tolower(c1);
    c2 = tolower(c2);
    
    /* Check for match */
    if (c1 != c2) {
      raiseErr(__LINE__, "Syntax error on line %s", lineString(lnum));
    }
    
    /* Advance in main string */
    pStr++;
  }
}

/*
 * Get a single alphanumeric character from the start of the given
 * string and normalize it to lowercase.
 * 
 * Parameters:
 * 
 *   pStr - the string
 * 
 *   lnum - the input line number (for diagnostic messages)
 * 
 * Return:
 * 
 *   the alphanumeric character code, normalized to lowercase
 */
static int parseAlphanum(const char *pStr, int32_t lnum) {
  
  int c = 0;
  
  /* Check parameters */
  if (pStr == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Get character and check range */
  c = *pStr;
  if (((c < '0') || (c > '9')) &&
      ((c < 'A') || (c > 'Z')) &&
      ((c < 'a') || (c > 'z'))) {
    raiseErr(__LINE__, "Syntax error on line %s", lineString(lnum));
  }
  
  /* Return character normalized to lowercase */
  return tolower(c);
}

/*
 * Parse a linear whitespace gap of at least one character at the start
 * of the string.
 * 
 * Parameters:
 * 
 *   pStr - the string
 * 
 *   lnum - the input line number (for diagnostic messages)
 * 
 * Return:
 * 
 *   the number of characters of linear whitespace at the start of the
 *   string, which will be at least one
 */
static int32_t parseGap(const char *pStr, int32_t lnum) {
  
  int32_t count = 0;
  
  if (pStr == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  if (!isLWS(*pStr)) {
    raiseErr(__LINE__, "Syntax error on line %s", lineString(lnum));
  }
  
  for( ; isLWS(*pStr); pStr++) {
    if (count < INT32_MAX) {
      count++;
    } else {
      raiseErr(__LINE__, "Integer overflow");
    }
  }
  
  return count;
}

/*
 * Parse an unsigned decimal integer at the start of the string.
 * 
 * Parameters:
 * 
 *   pStr - the string
 * 
 *   pVal - the variable to hold the parsed numeric value
 * 
 *   lnum - the input line number (for diagnostic messages)
 * 
 * Return:
 * 
 *   the number of decimal digits at the start of the string, which will
 *   be at least one
 */
static int32_t parseDecimal(
    const char    * pStr,
          int32_t * pVal,
          int32_t   lnum) {
  
  int32_t count = 0;
  int c = 0;
  
  if ((pStr == NULL) || (pVal == NULL)) {
    raiseErr(__LINE__, NULL);
  }
  
  if ((*pStr < '0') || (*pStr > '9')) {
    raiseErr(__LINE__, "Syntax error on line %s", lineString(lnum));
  }
  
  *pVal = 0;
  for( ; ((*pStr >= '0') && (*pStr <= '9')); pStr++) {
    if (count < INT32_MAX) {
      count++;
    } else {
      raiseErr(__LINE__, "Integer overflow");
    }
    
    if (*pVal <= INT32_MAX / 10) {
      *pVal *= 10;
    } else {
      raiseErr(__LINE__, "Integer out of range on line %s",
                lineString(lnum));
    }
    
    c = *pStr - '0';
    if (*pVal <= INT32_MAX - c) {
      *pVal += c;
    } else {
      raiseErr(__LINE__, "Integer out of range on line %s",
                lineString(lnum));
    }
  }
  
  return count;
}

/*
 * Check whether all remaining characters in a given string are linear
 * whitespace that pass isLWS().
 * 
 * Parameters:
 * 
 *   pStr - the string to check
 * 
 * Return:
 * 
 *   non-zero if string is empty or contains only linear whitespace,
 *   zero otherwise
 */
static int remBlank(const char *pStr) {
  
  int result = 1;
  
  if (pStr == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  for( ; *pStr != 0; pStr++) {
    if (!isLWS(*pStr)) {
      result = 0;
      break;
    }
  }
  
  return result;
}

/*
 * Comparator function to order events with qsort().
 * 
 * See the standard qsort() function for the interface.
 */
static int cmpEvent(const void *pA, const void *pB) {
  
  int result = 0;
  const EVENT *ea = NULL;
  const EVENT *eb = NULL;
  
  ea = (const EVENT *) pA;
  eb = (const EVENT *) pB;
  
  if (ea->t < eb->t) {
    result = -1;
    
  } else if (ea->t > eb->t) {
    result = 1;
    
  } else {
    if (ea->ch < eb->ch) {
      result = -1;
      
    } else if (ea->ch > eb->ch) {
      result = 1;
      
    } else {
      result = 0;
    }
  }
  
  return result;
}

/*
 * Add an event to the event table.
 * 
 * This function does not check that the event is valid.  It merely adds
 * it to the table.
 * 
 * The event is copied in.  No reference is made to the parameter after
 * this function.
 * 
 * Parameters:
 * 
 *   pe - the event to add a copy of
 */
static void addEvent(const EVENT *pe) {
  
  int32_t new_cap = 0;
  
  /* Check parameters */
  if (pe == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  /* If event table not initialized, initialize it */
  if (m_ev_cap < 1) {
    m_ev_cap = EVENT_INIT_CAP;
    m_ev_count = 0;
    m_ev = (EVENT *) calloc((size_t) m_ev_cap, sizeof(EVENT));
    if (m_ev == NULL) {
      raiseErr(__LINE__, "Out of memory");
    }
  }
  
  /* If event table full, expand it */
  if (m_ev_count >= m_ev_cap) {
    /* Check not at maximum capacity */
    if (m_ev_cap >= EVENT_MAX_CAP) {
      raiseErr(__LINE__, "Too many events");
    }
    
    /* New capacity is double current capacity, or maximum capacity,
     * whichever is lower */
    new_cap = m_ev_cap * 2;
    if (new_cap > EVENT_MAX_CAP) {
      new_cap = EVENT_MAX_CAP;
    }
    
    /* Expand the buffer size to new capacity */
    m_ev = (EVENT *) realloc(m_ev, sizeof(EVENT) * ((size_t) new_cap));
    if (m_ev == NULL) {
      raiseErr(__LINE__, "Too many events");
    }
    memset(
        &(m_ev[m_ev_cap]),
        0,
        ((size_t) (new_cap - m_ev_cap)) * sizeof(EVENT));
    
    /* Update capacity */
    m_ev_cap = new_cap;
  }
  
  /* Copy event to table */
  memcpy(&(m_ev[m_ev_count]), pe, sizeof(EVENT));
  m_ev_count++;
}

/*
 * Read and parse the header line from input.
 * 
 * The parameters read from the header are placed in the m_head module
 * variables.
 * 
 * Parameters:
 * 
 *   pIn - the file to read from
 */
static void readHeader(FILE *pIn) {
  
  const char *ps = NULL;
  int32_t iv = 0;
  int c = 0;
  int i = 0;
  
  /* Check parameter */
  if (pIn == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Read header line */
  ps = readLine(pIn);
  if (ps == NULL) {
    raiseErr(__LINE__, "Failed to read input header line");
  }
  
  /* First comes "RPF" */
  parseMatch(ps, "RPF", 1);
  ps += 3;
  
  /* Next comes a gap */
  ps += parseGap(ps, 1);
  
  /* Now a decimal value 1-1024 giving control rate */
  ps += parseDecimal(ps, &iv, 1);
  if ((iv < 1) || (iv > 1024)) {
    raiseErr(__LINE__, "Control rate out of range in header line");
  }
  m_head_rate = (int) iv;
  
  /* Another gap */
  ps += parseGap(ps, 1);
  
  /* The performance mode as a single letter normalized to lowercase */
  c = parseAlphanum(ps, 1);
  ps++;
  
  if (c == 'm') {
    m_head_rhythm = 0;
  } else if (c == 'r') {
    m_head_rhythm = 1;
  } else {
    raiseErr(__LINE__, "Syntax error in header line");
  }
  
  /* Further parsing depends on mode */
  if (m_head_rhythm) {
    /* Rhythm mode, so parse the three parameters */
    for(i = 0; i < 3; i++) {
      /* First comes a gap */
      ps += parseGap(ps, 1);
      
      /* Next comes appropriate parameter declaration */
      if (i == 0) {
        parseMatch(ps, "B=", 1);
        ps += 2;
        
      } else if (i == 1) {
        parseMatch(ps, "S=", 1);
        ps += 2;
        
      } else if (i == 2) {
        parseMatch(ps, "T=", 1);
        ps += 2;
        
      } else {
        raiseErr(__LINE__, NULL);
      }
      
      /* Parse value */
      if (*ps == '?') {
        /* Undefined value, so -1 */
        c = -1;
        ps++;
        
      } else {
        /* Defined value, so parse as frequency format */
        c = parseFreqF(ps, 1);
        ps += FREQF_LEN;
      }
      
      /* Set appropriate module variable */
      if (i == 0) {
        m_head_b_def = c;
        
      } else if (i == 1) {
        m_head_s_def = c;
        
      } else if (i == 2) {
        m_head_t_def = c;
        
      } else {
        raiseErr(__LINE__, NULL);
      }
    }
    
  } else {
    /* Not in rhythm mode, so clear default values */
    m_head_b_def = -1;
    m_head_s_def = -1;
    m_head_t_def = -1;
  }
  
  /* Make sure nothing but blank remains */
  if (!remBlank(ps)) {
    raiseErr(__LINE__, "Syntax error in header line");
  }
  
  /* Set initialization flag */
  m_head_init = 1;
}

/*
 * Parse an input line and add any defined event.
 * 
 * This does NOT handle the header line, however.  Blank and comment
 * lines will have no effect.
 * 
 * The header variables must be initialized first.
 * 
 * Parameters:
 * 
 *   pStr - the line to parse
 * 
 *   lnum - the input line number (for diagnostics)
 */
static void parseLine(const char *pStr, int32_t lnum) {
  
  int32_t iv = 0;
  int c = 0;
  EVENT ev;
  
  /* Initialize structures */
  memset(&ev, 0, sizeof(EVENT));
  
  /* Check parameters */
  if (pStr == NULL) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Check state */
  if (!m_head_init) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Only proceed if line is not blank */
  if (!remBlank(pStr)) {
    /* Only proceed if not a comment */
    if (*pStr != '\'') {
      
      /* Parse the event */
      if ((*pStr == 'N') || (*pStr == 'n')) {
        /* Null event, so first match the N */
        parseMatch(pStr, "N", lnum);
        pStr++;
        
        /* Next comes a gap */
        pStr += parseGap(pStr, lnum);
        
        /* The time offset as a decimal integer */
        pStr += parseDecimal(pStr, &iv, lnum);
        
        /* Rest of the line is blank */
        if (!remBlank(pStr)) {
          raiseErr(__LINE__, "Syntax error on line %s",
                    lineString(lnum));
        }
        
        /* Add the null event to the table */
        ev.t = iv;
        ev.dur = 0;
        ev.freq = (int16_t) -1;
        ev.ch = (int8_t) -1;
        
        addEvent(&ev);
        
      } else {
        /* Not a null event, so first read the time offset and the
         * duration, separated by a colon */
        pStr += parseDecimal(pStr, &iv, lnum);
        ev.t = iv;
        
        parseMatch(pStr, ":", lnum);
        pStr++;
        
        pStr += parseDecimal(pStr, &iv, lnum);
        if (iv < 2) {
          raiseErr(__LINE__, "Duration must be at least 2 on line %s",
                      lineString(lnum));
        }
        ev.dur = iv;
        
        /* Next comes a gap */
        pStr += parseGap(pStr, lnum);
        
        /* Now an alphanumeric character selecting the channel or the
         * percussion instrument */
        c = parseAlphanum(pStr, lnum);
        pStr++;
        
        /* Set the channel element in the event */
        if ((c >= '1') && (c <= '9')) {
          ev.ch = (int8_t) (c - '0');
          
        } else if (c == 'b') {
          ev.ch = (int8_t) 20;
          
        } else if (c == 's') {
          ev.ch = (int8_t) 21;
          
        } else if (c == 't') {
          ev.ch = (int8_t) 22;
          
        } else if (c == 'h') {
          ev.ch = (int8_t) 31;
          
        } else if (c == 'c') {
          ev.ch = (int8_t) 32;
          
        } else {
          raiseErr(__LINE__, "Invalid channel code on line %s",
                    lineString(lnum));
        }
        
        /* Get frequency if defined, else set to -1 */
        if (!remBlank(pStr)) {
          /* Frequency information, so next comes a gap */
          pStr += parseGap(pStr, lnum);
          
          /* Parse the frequency information */
          ev.freq = (int16_t) parseFreqF(pStr, lnum);
          pStr += FREQF_LEN;
          
          /* Nother further on the line */
          if (!remBlank(pStr)) {
            raiseErr(__LINE__, "Syntax error line %s",
                      lineString(lnum));
          }
          
        } else {
          /* No frequency information */
          ev.freq = (int16_t) -1;
        }
        
        /* If rhythm event, make sure rhythm mode is on */
        if (ev.ch >= 20) {
          if (!m_head_rhythm) {
            raiseErr(__LINE__,
              "Can't use drums in melodic performance on line %s",
              lineString(lnum));
          }
        }
        
        /* If channel 7-9, make sure rhythm mode is off */
        if ((ev.ch >= 7) && (ev.ch <= 9)) {
          if (m_head_rhythm) {
            raiseErr(__LINE__,
              "Can't use channels 7-9 in rhythm performance on line %s",
              lineString(lnum));
          }
        }
        
        /* If a pitched rhythm instrument without a frequency, fill in
         * with the default from the header */
        if ((ev.ch == 20) && (ev.freq < 0)) {
          ev.freq = (int16_t) m_head_b_def;
        
        } else if ((ev.ch == 21) && (ev.freq < 0)) {
          ev.freq = (int16_t) m_head_s_def;
          
        } else if ((ev.ch == 22) && (ev.freq < 0)) {
          ev.freq = (int16_t) m_head_t_def;
        }
        
        /* Make sure hi-hat and cymbal do not have frequency */
        if ((ev.ch >= 30) && (ev.freq < 0)) {
          raiseErr(__LINE__,
            "Hi-hat and cymbal can't have frequency on line %s",
            lineString(lnum));
        }
        
        /* Make sure everything else has a frequency now that defaults
         * have been filled in */
        if ((ev.ch < 30) && (ev.freq < 0)) {
          raiseErr(__LINE__,
            "Missing required frequency on line %s",
            lineString(lnum));
        }
        
        /* Add event to table */
        addEvent(&ev);
      }
    }
  }
}

/*
 * Release registers in the wait array.
 * 
 * m_st_init must be set.
 * 
 * max_t is the maximum time offset that can be released, or -1 if there
 * is no maximum.
 * 
 * This function will output OPL2 wait and register commands to standard
 * output necessary to release any registers.  If max_t is -1, then all
 * registers will be released when this function returns.  Otherwise,
 * registers will only be released up to and including max_t.
 * 
 * Parameters:
 * 
 *   max_t - the maximum time offset to release, or -1 for no maximum
 */
static void releaseRegisters(int32_t max_t) {
  
  int i = 0;
  int next_i = 0;
  int32_t next_t = 0;
  
  /* Check parameters and state */
  if (max_t < -1) {
    raiseErr(__LINE__, NULL);
  }
  
  if (!m_st_init) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Processing loop */
  while (1) {
    /* Find the next index that needs to be released, or -1 if none of
     * them do */
    next_i = -1;
    next_t = -1;
    for(i = 0; i < 14; i++) {
      if (m_st_wta[i] >= 0) {
        if (next_i >= 0) {
          if (m_st_wta[i] < next_t) {
            next_i = i;
            next_t = m_st_wta[i];
          }
          
        } else {
          next_i = i;
          next_t = m_st_wta[i];
        }
      }
    }
    
    /* Leave loop if nothing left to release */
    if (next_i < 0) {
      break;
    }
    
    /* Leave loop if next thing to release is after the maximum t */
    if (max_t >= 0) {
      if (next_t > max_t) {
        break;
      }
    }
    
    /* We have something we need to release; first of all, advance the
     * time offset up to the release time */
    if (m_st_t < next_t) {
      printf("w %ld\n", (long) (next_t - m_st_t));
      m_st_t = next_t;
    }
    
    /* Issue the appropriate release register write and update channel
     * state */
    if ((next_i >= 0) && (next_i <= 8)) {
      /* Melodic channel, so clear key-on flag of appropriate channel */
      m_st_reg[next_i] &= 0xdf;
      
      /* Update the channel with a register write */
      printf("r %02x %02x\n", 0xb0 + next_i, m_st_reg[next_i]);
      
    } else if ((next_i >= 9) && (next_i <= 13)) {
      /* Percussion channel, so clear appropriate instrument flag */
      if (next_i == 9) {
        /* Bass drum */
        m_st_reg[9] &= 0xef;
        
      } else if (next_i == 10) {
        /* Snare drum */
        m_st_reg[9] &= 0xf7;
        
      } else if (next_i == 11) {
        /* Tom-tom */
        m_st_reg[9] &= 0xfb;
        
      } else if (next_i == 12) {
        /* Hi-hat */
        m_st_reg[9] &= 0xfe;
        
      } else if (next_i == 13) {
        /* Cymbal */
        m_st_reg[9] &= 0xfd;
        
      } else {
        raiseErr(__LINE__, NULL);
      }
      
      /* Update the percussion with a register write */
      printf("r %02x %02x\n", 0xbd, m_st_reg[9]);
      
    } else {
      raiseErr(__LINE__, NULL);
    }
    
    /* Clear the channel in the waiting array */
    m_st_wta[next_i] = -1;
  }
}

/*
 * Begin a note event at the current time offset.
 * 
 * m_st_init must be set.
 * 
 * ch is the channel the note is on.  This has the same values as the ch
 * element in the EVENT structure, except -1 is not allowed.
 * 
 * freq is the frequency of the event, which must be set for everything
 * except hi-hat and cymbal, for which it must be -1.  The format is the
 * same as is returned by parseFreqF().
 * 
 * dur is the duration of the event, which must be at least 2.
 * 
 * This function will first check that no event is currently active on
 * the indicated channel.  Then, it will update the register state and
 * print appropriate OPL2 register commands on standard output to turn
 * the note on.  Finally, it will schedule the release of the note in
 * the wait array.
 * 
 * Parameters:
 * 
 *   ch - the channel value of the note, as in the EVENT structure
 * 
 *   freq - the frequency of the event or -1
 * 
 *   dur - the duration of the event
 */
static void beginNote(int ch, int freq, int32_t dur) {
  
  int v = 0;
  int32_t t_last = 0;
  
  /* Check parameters */
  if (((ch < 1) || (ch > 9)) &&
      ((ch < 20) || (ch > 22)) &&
      ((ch < 31) || (ch > 32))) {
    raiseErr(__LINE__, NULL);
  }
  
  if (ch < 30) {
    if ((freq < 0) || (freq > 0x1fff)) {
      raiseErr(__LINE__, NULL);
    }
  } else {
    if (freq != -1) {
      raiseErr(__LINE__, NULL);
    }
  }
  
  if (dur < 2) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Check state */
  if (!m_st_init) {
    raiseErr(__LINE__, NULL);
  }
  
  /* Convert channel to index into wait array */
  if ((ch >= 1) && (ch <= 9)) {
    ch--;
    
  } else if ((ch >= 20) && (ch <= 22)) {
    ch = (ch - 20) + 9;
    
  } else if ((ch >= 31) && (ch <= 32)) {
    ch = (ch - 31) + 12;
    
  } else {
    raiseErr(__LINE__, NULL);
  }
  
  /* Check that channel is not active */
  if (m_st_wta[ch] >= 0) {
    raiseErr(__LINE__, "Overlapping channel events at time %ld in %d",
              (long) m_st_t, ch);
  }
  
  /* Update state and issue register commands */
  if (ch < 9) {
    /* Melodic channel, so update stored register */
    m_st_reg[ch] = (freq >> 8) | 0x20;
    
    /* Issue appropriate write commands */
    printf("r %02x %02x\n", 0xa0 + ch, freq & 0xff);
    printf("r %02x %02x\n", 0xb0 + ch, (freq >> 8) | 0x20);
    
  } else {
    /* Percussion instrument */
    if (ch == 9) {
      /* Bass drum */
      m_st_reg[9] |= 0x10;
      
      printf("r %02x %02x\n", 0xa6, freq & 0xff);
      printf("r %02x %02x\n", 0xb6, freq >> 8);
      printf("r %02x %02x\n", 0xbd, m_st_reg[9]);
      
    } else if (ch == 10) {
      /* Snare drum */
      m_st_reg[9] |= 0x08;
      
      printf("r %02x %02x\n", 0xa7, freq & 0xff);
      printf("r %02x %02x\n", 0xb7, freq >> 8);
      printf("r %02x %02x\n", 0xbd, m_st_reg[9]);
      
    } else if (ch == 11) {
      /* Tom-tom */
      m_st_reg[9] |= 0x04;
      
      printf("r %02x %02x\n", 0xa8, freq & 0xff);
      printf("r %02x %02x\n", 0xb8, freq >> 8);
      printf("r %02x %02x\n", 0xbd, m_st_reg[9]);
      
    } else if (ch == 12) {
      /* Hi-hat */
      m_st_reg[9] |= 0x01;
      printf("r %02x %02x\n", 0xbd, m_st_reg[9]);
      
    } else if (ch == 13) {
      /* Cymbal */
      m_st_reg[9] |= 0x02;
      printf("r %02x %02x\n", 0xbd, m_st_reg[9]);
      
    } else {
      raiseErr(__LINE__, NULL);
    }
  }
  
  /* Compute the release time, watching for overflow */
  dur--;
  if (dur <= INT32_MAX - m_st_t) {
    t_last = m_st_t + dur;
  } else {
    raiseErr(__LINE__, "Time offset overflow");
  }
  
  /* Add the release time to the wait array */
  m_st_wta[ch] = t_last;
}

/*
 * Program entrypoint
 * ==================
 */

int main(int argc, char *argv[]) {
  
  const char    * pStagePath = NULL;
        int32_t   perf_wait  = -1;
  
  int i = 0;
  int32_t lnum = 0;
  const char *pl = NULL;
  const EVENT *pe = NULL;
  int32_t event_i = 0;
  
  /* Initialize diagnostics and check arguments */
  diagnostic_startup(argc, argv, "retro_compile");
  
  /* Interpret options */
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-stage") == 0) {
      i++;
      if (i >= argc) {
        raiseErr(__LINE__, "Program option %s missing parameter",
                  argv[i - 1]);
      }
      if (pStagePath != NULL) {
        raiseErr(__LINE__, "Duplicate option: %s", argv[i - 1]);
      }
      pStagePath = argv[i];
      
    } else if (strcmp(argv[i], "-wait") == 0) {
      i++;
      if (i >= argc) {
        raiseErr(__LINE__, "Program option missing parameter");
      }
      if (perf_wait >= 0) {
        raiseErr(__LINE__, "Duplicate option: %s", argv[i - 1]);
      }
      perf_wait = parseInt(argv[i]);
      
    } else {
      raiseErr(__LINE__, "Unrecognized program option: %s",
                argv[i]);
    }
  }
  
  /* Set default values for optional options */
  if (perf_wait < 0) {
    perf_wait = 0;
  }
  
  /* Check for required options */
  if (pStagePath == NULL) {
    raiseErr(__LINE__, "Missing required option: -stage");
  }
  
  /* Load the stage */
  loadStage(pStagePath);
  
  /* Read header from input */
  readHeader(stdin);
  
  /* Process the rest of the lines */
  lnum = 1;
  for(pl = readLine(stdin); pl != NULL; pl = readLine(stdin)) {
    /* Increase line number */
    if (lnum < INT32_MAX) {
      lnum++;
    }
    
    /* Parse the line and possibly add an event */
    parseLine(pl, lnum);
  }
  
  /* If more than one event, sort events first by their time offset and
   * second by their channel */
  if (m_ev_count > 1) {
    qsort(m_ev, (size_t) m_ev_count, sizeof(EVENT), &cmpEvent);
  }
  
  /* Write the OPL2 script header */
  printf("OPL2 %d\n", m_head_rate);
  
  /* Set the stage */
  for(i = 0; i < 256; i++) {
    if (m_stage[i] >= 0) {
      printf("r %02x %02x\n", i, (int) m_stage[i]);
    }
  }
  
  /* If non-zero performance delay, insert a wait */
  if (perf_wait > 0) {
    printf("w %ld\n", (long) perf_wait);
  }
  
  /* Initialize the sequencer state */
  for(i = 0; i < 14; i++) {
    m_st_wta[i] = -1;
  }
  for(i = 0; i < 10; i++) {
    m_st_reg[i] = 0;
  }
  m_st_t = 0;
  m_st_init = 1;
  
  /* If percussion register is defined in the stage, copy it to register
   * state */
  if (m_stage[0xbd] >= 0) {
    m_st_reg[9] = (int) m_stage[0xbd];
  }
  
  /* Go through the event table */
  for(event_i = 0; event_i < m_ev_count; event_i++) {
    /* Get the current event */
    pe = &(m_ev[event_i]);
    
    /* Release any events in the wait array that have a time offset less
     * than the current event */
    if (pe->t > 0) {
      releaseRegisters(pe->t - 1);
    }
    
    /* Advance to current event */
    if (pe->t > m_st_t) {
      printf("w %ld\n", (long) (pe->t - m_st_t));
      m_st_t = pe->t;
    }
    
    /* If current event is not a null event, begin it */
    if (pe->dur > 0) {
      beginNote(pe->ch, pe->freq, pe->dur);
    }
  }
  
  /* Release any registers that have scheduled release events */
  releaseRegisters(-1);
  
  /* If we got here, return successfully */
  return EXIT_SUCCESS;
}
