# Retro Synthesizer Specification

The Retro synthesizer is based on OPL2 hardware.  OPL2 was the most common hardware for producing polyphonic video game music in the late 80s and early 90s on the DOS platform, so Retro produces results that sound like they came from a DOS computer game.  OPL2 was used in AdLib and SoundBlaster cards.  AdLib Gold, SoundBlaster Pro 2, and SoundBlaster 16 cards had OPL3 chips, which offer additional capabilities but are also backwards compatible with OPL2.

Retro does not actually generate the synthesized sound samples.  Instead, Retro generates a hardware script file that indicates which values need to be written to which OPL2 hardware registers at what time.  Executing the hardware script against OPL2 hardware will cause the hardware to synthesize the sound.  You can also run the hardware script against various available OPL2 software emulators and directly capture the synthesized digital samples without any OPL2 hardware required.

## Sampling and control rates

The **sampling rate** is the constant rate at which digital sound samples are played back.  Actual OPL2 hardware uses a sampling rate of approximately 49,716 samples per second.  For the most part, however, the OPL2 sampling rate is an internal hardware detail and not visible to software programs.  Software programs change the hardware registers of the OPL2, and the changes to the hardware registers immediately affect the sound the OPL2 produces.  The digital samples produced by the OPL2 hardware are sent directly to a Digital to Analog Converter (DAC) and there is no way for the software to read the digital samples produced by the OPL2.

There is only one case in which the OPL2's internal sampling rate of 49,716 Hz is visible to software.  When setting the frequency of a channel, the formula for computing the frequency number that is written into the hardware registers involves 49,716 as a constant.

Software written for the OPL2 is timed according to a **control rate** that is completely independent from the sampling rate.  Software uses the control rate to time its writes to the hardware registers of the OPL2.  The OPL2, however, does not care about the control rate.  The OPL2 simply changes its output the moment its hardware registers are changed.  In DOS software, the control rate might be generated by separate timing hardware that is unrelated to the OPL2.

Historic software designed for OPL2 hardware used a wide range of control rates.  For example, Sierra games using the SCI interpreter had a control rate of 60 Hz.  On the other hand, the id Software title _Wolfenstein_ used a control rate of 700 Hz.

Retro allows you choose any control rate that is an integer value in range [1 Hz, 1024 Hz].  On software emulations of OPL2 hardware, you might choose the control rate such that the sampling rate used by the OPL2 software emulation is divisible by the control rate.  This has the useful property that one cycle at the control rate produces an integer number of digital samples.  For example, if the OPL2 software emulation has a sampling rate of 44,100 Hz and the control rate is 60 Hz, then each cycle at the control rate will produce exactly 735 digital samples.

For actual OPL2 hardware, there is no reason to synchronize the control rate with the internal sampling rate used by the hardware.  However, actual OPL2 hardware has a limit to how fast you can change the hardware registers.  Only one byte can be written to OPL2 hardware at a time, and it takes about 3.3 microseconds to write the address and 23 microseconds to write the data byte.  The OPL2 synthesizer state controlled by Retro has 118 bytes, so it takes about 3103.4 microseconds to fully change the synthesizer state on OPL2 hardware.  This means the full synthesizer state can be changed at most about 322 times per second.

Consequently, if you are using Retro to target actual OPL2 hardware, you may want to choose a control rate comfortably below 322 Hz.  If your control rate is close to or above 322 Hz, then it is possible that Retro's hardware script changes hardware registers faster than the OPL2 hardware can handle.  However, you may only hit this limit if you have an unusually complex composition with lots of extremely fast synthesizer state changes.  Testing on actual hardware is the best way to check whether you are outrunning what the OPL2 is capable of handling.

Software emulations of OPL2 hardware can instantly change register states and therefore it is impossible to change software-emulated hardware registers too fast.

## Cycles

Timing within Retro synthesis scripts is measured in **cycles.**  The length of a cycle in seconds is derived from the control rate by the following formula:

                           1
    cycle (sec.) = -----------------
                   control rate (Hz)

For example, if the control rate is 60 Hz, then one cycle will be approximately 0.0167 seconds.  Since the range of control rates supported by Retro is [1 Hz, 1024 Hz], the range of cycle units is approximately [0.00098 sec, 1 sec].

## State categories

Retro organizes OPL2 hardware state into the following categories:

1. Global parameters
2. Channel parameters
3. Operator parameters
4. Note control
5. Drum control

**Global parameters** are those parts of hardware state that affect the whole OPL2 and whose effects apply to multiple events.  There are two global parameters controlling the depth of amplitude and frequency vibrato used by all operators.  There are also two global parameters controlling composite sine wave mode and the keyboard split point, both of which are poorly documented features that no one seems to know how to use.

**Channel parameters** are those parts of hardware state that affect one whole _channel_ of the OPL2 and whose effects apply to multiple events.  OPL2 has nine channels, which Retro always numbers in range [0, 8].  (Be careful: some OPL2 documentation sources number the channels [1, 9].)

**Operator parameters** are those parts of hardware state that affect one specific _operator_ and whose effects apply to multiple events.  Each OPL2 channel has two operators, which Retro always numbers as operator zero and operator one.  (Be careful: some OPL2 documentation sources number the operators as one and two.)  Therefore, the OPL2 has 18 operators in total.

**Note control** are those parts of hardware state that affect one whole channel but whose effects only apply to a single event.  Note control merely consists of a single flag in each channel that indicates whether a melodic note is currently in key-down state within that channel or not.

**Drum control** are those parts of hardware state that affect the whole OPL2 but whose effects only apply to a single event.  Drum control consists of a flag indicating whether the OPL2 is in _rhythm mode,_ and five flags indicating which combination of percussion instruments is currently active.  The OPL2 supports the following five percussion instruments:

1. Bass drum
2. Snare drum
3. Tom-tom
4. Cymbal
5. Hi-hat

## Default values

Retro defines **default values** for each element of state.  The default for note control state is all key-down flags turned off.  The default for drum control state is rhythm mode disabled and all percussion flags turned off.  The default values for global parameters, channel parameters, and operator parameters are documented later when each of the specific parameters is defined.

When default values are referred to in subsequent sections of this specification, the meaning is the specific default value defined by this Retro specification for the indicated element of state.

## State consistency

The hardware state at each point in time must be **consistent,** or the behavior of the OPL2 hardware will be undefined.  For the state to be consistent, each state component must have a value that is within the valid range and the following consistency rules must be upheld:

**Consistency Rule #1:** When any of the percussion instrument flags are active in drum control state, the rhythm mode flag in drum control state must be set.

**Consistency Rule #2:** When the rhythm mode flag in drum control state is set, the key-down flags for channels 6, 7, and 8 in note control state must all be clear.

The reason for the consistency rules is that the OPL2 does not have separate hardware for the percussion instruments.  Instead, the percussion instruments use channels 6, 7, and 8 reconfigured in a special, interconnected way.  The rhythm mode flag sets channels 6, 7, and 8 into this special percussion arrangement and must therefore always be active when the percussion instruments are in use (Consistency Rule #1).  Also, channels 6, 7, and 8 can not be used for melodic notes while they are configured in rhythm mode (Consistency Rule #2).

## Pseudo-channel state

Retro also keeps track of state for three **pseudo-channels** that do not actually exist on OPL2 hardware.  The three pseudo-channels are R0, R1, and R2.  The pseudo-channels have their own complete sets of channel and operator parameters.  However, the pseudo-channels lack note control flags.

When the OPL2 is in rhythm mode, the state of channels 6, 7, and 8 affect the sound of the percussion instruments, since those channels are used to synthesize percussion instruments.  Usually, you will want a special set of channel and operator settings to be active in channels 6, 7, and 8 whenever you are using percussion instruments, so that the percussion instruments will have the correct synthesized sound.

The pseudo-channels R0, R1, and R2 store the channel and operator settings for rhythm-mode use of channels 6, 7, and 8.  When rhythm mode is turned on, Retro will copy the settings stored in pseudo-channels R0, R1, and R2 into channels 6, 7, and 8.  While rhythm mode remains on, any changes to parameter values in R0, R1, and R2 due to graphs will be immediately reflected to channels 6, 7, and 8.  When rhythm mode is turned off, further changes to R0, R1, and R2 will no longer be reflected to channels 6, 7, and 8.

Since R0, R1, and R2 are only active when rhythm mode is engaged, the key-down flags in channels 6, 7, and 8 must always be clear while R0, R1, and R2 are in use due to Consistency Rule #2.  This is why the pseudo-channels lack note control flags.  The key-down flags must always be off for the pseudo-channels, so there is no need to track their state.

In short, the pseudo-channels R0, R1, and R2 represent the state of channels 6, 7, and 8 when those channels are used in rhythm mode.

## Parameter names and values

Retro gives each global parameter, channel parameter, and operator parameter an ASCII name.  Parameter names always have a length in range [1, 8] and only contain alphabetic letters and underscores.  Global parameter names always have an underscore as their first character.  Channel parameter names always have an uppercase letter for their first character and any following characters are lowercase.  Operator parameter names are always entirely in lowercase.

The value of each parameter is an integer or a _graph._  For all parameters except the `F` parameter, the full range of allowed integer values is a subset of the range [0, 63].  The `F` parameter exceptionally has an integer range of [0, 117824].

Graphs are used for parameter values that change over time.  Graphs are basically functions that take a time point as input and produce an integer parameter value as output.  The details of how graphs work are described in a later section.

## Events

The Retro synthesizer compiles a set of _events_ into a hardware script that plays those events back on emulated OPL2 hardware.  Each event is specified independently from all other events.

Each event has an _offset,_ a _reserved duration,_ and an _audible duration_ that determines when the event takes place.  The offset of an event is the time at which the event starts making sound.  The offset is measured as the number of cycles that have elapsed since the start of the performance.  This offset must be an integer value that is zero or greater.

There are two different durations for each event:  a reserved duration and an audible duration.  Both durations are measured as an integer number of cycles.  The audible duration must be at least one, and the reserved duration must be greater than the audible duration.  (So, the reserved duration is always at least two.)

Retro will tell the OPL2 that a melodic channel or percussion instrument is on only during the audible duration.  At the start of the reserved duration, Retro will tell the OPL2 to turn the melodic channel or percussion instrument off.  Retro will then leave the melodic channel or percussion instrument off for the rest of the reserved duration.  This is necessary so that the OPL2 knows when notes end.  Having a reserved duration greater than one may be necessary to allow for the full release phase of the ADSR envelope, which takes place after the note has been released.

There are two kinds of events:  _melodic events_ and _rhythm events._  Melodic events can be performed on any of the OPL2's nine channels, except they may not be performed on channels 6, 7, or 8 when rhythm mode is enabled, due to Consistency Rule #2.  Rhythm events can only be performed when rhythm mode is enabled.  Rhythm events use percussion instruments that are synthesized on a special combination of channels 6, 7, and 8.

The following subsections describe melodic and rhythmic events in further detail.

### Melodic events

Melodic events must specify a full set of channel parameter values for one channel and two full sets of operator parameter values for the two operators within that channel.  To avoid giving a long list of parameters for each individual melodic event, melodic events inherit channel and operator parameter values from an **instrument.**  Individual melodic events then only need to specify those parameter values that differ from the inherited values.

Each instrument has a _parent_ that is either a different instrument or a null reference.  Circular references and self references within instrument derivation chains are not allowed.  Each instrument also has three sets of parameter values, each of which may be empty.  The first set stores channel parameters.  The second and third sets store operator parameters for operator zero and operator one, respectively.

For instruments that have a null parent reference, all channel and operator parameters start with their default values.  The instrument need only define those parameters that differ from the default values.  Any parameter value defined by the instrument overrides the default value.  Instrument parameter definitions may use both integer values and graphs.

For instruments that have a non-null parent reference, the channel parameters and the operator parameters for each operator are inherited from the parent instrument.  The instrument then need only defined those parameters that differ from the inherited values.

Melodic events inherit their channel, operator zero, and operator one parameters from the instrument they reference.  Individual melodic events only need to specify those parameters that are different from the inherited values.

The parameter most frequently changed by individual melodic events is the channel frequency `F`.  Melodic events therefore have a special property for the `F` channel parameter, which may be left undefined if it should be inherited from the instrument.  This special property is an optimization, so that in the frequent case that a melodic event only needs to change the `F` channel parameter, it can just use this special property and leave all of the parameter sets within the event undefined.

In short, melodic events contain an offset, reserved duration, and audible duration measured in cycles, an instrument reference, an `F` value or null, and three sets of parameter values for channel parameters, operator zero parameters, and operator one parameters.  Channel and operator parameter values are inherited from the instrument, then modified by the three parameter value sets, and finally modified by the `F` value.

Each melodic event also implies that the key-down flag for whichever channel it is assigned to should be turned on at the start of the event, left on for the audible duration, and turned off for the remaining reserved duration.

### Rhythm events

Rhythm events must select one of the five percussion instruments: bass drum, snare drum, tom-tom, cymbal, or hi-hat.  A rhythm event therefore contains an offset, reserved duration, and audible duration measured in cycles, and a selection of one of the five percussion instruments.

Each rhythm event also implies that the rhythm mode flag should be turned on for the whole reserved duration of the event, and that the selected percussion instrument flag should be turned on at the start of the event, kept on through the audible duration of the event, and turned off for the remaining reserved duration.

Rhythm events do not include parameter values.  Instead, the pseudo-channels R0, R1, and R2 determine the channel and operator settings that are used for channels 6, 7, and 8 while the rhythm mode flag is set.

## Event scheduling

OPL2 hardware has a limited number of channels, so there can only be a certain number of events happening simultaneously.  For purposes of determining whether two events are simultaneous, the reserved duration is included.  That is, two events may overlap and be considered simultaneous even if they are not producing sound at the same time.

The following limits apply to scheduling simultaneous events:

**Scheduling Rule #1:**  There can be at most nine simultaneous melodic events.

**Scheduling Rule #2:**  There can be at most six melodic events simultaneous with a rhythm event.

**Scheduling Rule #3:**  No two rhythm events for the same percussion instrument may be simultaneous.  However, rhythm events for different percussion instruments may be simultaneous in any combination.

If the scheduling rules are not obeyed, Retro will always fail with an error.  For example, there is no way to have ten simultaneous melodic events on the OPL2 because there are only nine channels.

However, even if all the scheduling rules are obeyed, Retro may still sometimes fail with an error due to scheduling.  This happens in certain edge cases where seven or more melodic events are simultaneous shortly before rhythm mode is activated.  If there is a lot of complex overlap between the seven or more melodic events, then Retro may not be able to figure out how to assign these events to channels such that channels 6, 7, and 8 are free when rhythm mode is activated, which would violate Consistency Rule #2.

To avoid these edge cases in scheduling, avoid having more than six melodic events leading up to the start of a rhythm block.  If you include a _synchronization point_ before the rhythm block starts, and you do not use more than six melodic voices after the synchronization point until the start of the rhythm block, then it is guaranteed there will be no scheduling error.  A synchronization point is a cycle _t_ such that every melodic event that overlaps _t_ is on the last cycle of its reserved duration at _t_.  A cycle _t_ which no melodic events overlap also qualifies as a synchronization point.

## Graphs

Global, channel, and operator parameter values may either be integer values or _graphs._  A graph allows the value of a parameter to change over time.  The same graph object may be shared across multiple parameter.

There are two kinds of graphs:  **base graphs** and **derived graphs.**  Base graphs are a complete, standalone definition of a graph.  Derived graphs reference another graph and are identical to the referenced graph, except each graph value produced by the referenced graph is adjusted as it passes through the derived graph.

### Base graphs

Base graphs describe a function `f(t)` that takes a time offset `t` as input and produces an integer parameter value `v` as output.  The input value `t` must be an integer that is greater than or equal to zero.  The output value `v` is an integer in 17-bit unsigned integer range [0, 131072].

Base graphs are either _global_ or _local._  In a global graph, `t` value zero corresponds to the start of the performance.  In a local graph, `t` value zero corresponds to the start of the current melodic event.  Instruments and melodic events may use both global and local graphs for their channel and operator parameter values.  Global parameter values may only use global graphs, and channel and operator parameter values for the pseudo-channels R0, R1, and R2 may only use global graphs.

A global graph is appropriate for effects that span multiple events over time.  For example, a long crescendo can be modeled as a global graph for amplitude.  Each individual event would then have its amplitude value synchronized with all the other events participating in the crescendo effect.

A local graph is appropriate for effects localized to an individual event.  For example, a pitch bend at the start of a note can be modeled as a local graph for frequency.  The same pitch bend graph can be used for multiple events, and each event will then have its own, localized pitch bend.

The graph function `f(t)` is defined by a sequence of **blocks,** a **repeat offset,** and a **repeat length.**  Each block has a length in cycles `n` that must be a finite value greater than zero.  The blocks define a finite subdomain of the function starting at `t` zero, with the start of the first block at `t` zero, and the start of each subsequent block immediately after the preceding block.  Therefore, the first block with length `n` defines the graph function for `t` in range `[0, n-1]`, the second block with length `m` defines the graph function for `t` in range `[n, n+m-1]`, and so forth.

The repeat offset is a `t` value that is within the subdomain of one of the blocks.  The repeat length `r` is an integer greater than zero, such that `(t + r - 1)` is also within the subdomain of one of the blocks.  (Not necessarily the same block as `t`.)  The finite `t` subdomain defined by the sequence of blocks is extended to positive infinity by looping values from `t` to `(t + r - 1)`.

Retro supports two kinds of blocks:  **planes** and **ramps.**  A plane block simply returns a constant value throughout its subdomain.  A ramp block has different values at the start and end of the block, and uses linear interpolation within the block.

More specifically, ramp blocks have a start value, a goal value, and a step count.  The start value and goal value may both have any 17-bit unsigned integer value.  For the first `t` covered by the ramp block's subdomain, the start value will be returned.  The last `t` covered by the ramp block's subdomain does _not_ reach the goal value, however.  Instead, the remaining `t` values in the ramp block are linearly interpolated such that the `t` value immediately following the ramp block would be the goal value.  This allows ramp blocks to be smoothly connected to each other.

The step count of a ramp block must be an integer value that is one or greater.  With a value of one, linear interpolation happens each cycle.  With a value of two, linear interpolation happens once every two cycles, and each pair of cycles repeats the same linear interpolation value.  With a value of three, linear interpolation happens once every three cycles, and each group of three cycles repeats the same linear interpolation value.

The step count is intended for ramps that have a long duration, such as might occur for an amplitude ramp on a long crescendo.  Increasing the step count decreases the number of times the parameter value changes during the ramp, which decreases the number of hardware registers writes that need to be made.

Ramp blocks that have the same start and goal value are automatically replaced by plane blocks with that constant value.  Ramp blocks that have a step count greater than or equal to the length of the ramp block are automatically replaced by plane blocks with the start value.

### Derived graphs

Derived graphs must reference an existing base or derived graph.  (No circular or self references are allowed.)  Derived graphs are exactly the same as the graph they reference, except that each value `v` generated by the referenced graph is changed to a different value `w` when it passes through the derived graph according to the following formula:

    w = max(min(floor((s * v) / d) + p, b), a)

First, the integer value `s` is multiplied to the input integer value.  Second, the result of this is divided by the integer value `d`.  Third, the result of that is added to `p`.  Finally, the result is clamped to the integer range `[a, b]`.  `s` must be in range [0, 32767], `d` must be in range [1, 32767], `p` must be in range [-117824, 117824], and `a` and `b` must be in range [0, 117824].

## OPL2 parameters

This section documents all the OPL2 global, channel, and operator parameters, along with their default values and maximum valid values.  The range of valid values for each parameter is zero up to and including the maximum valid value.

Global parameters:

    "_avib" - Global amplitude vibrato depth, default 0, max 1.
    "_fvib" - Global frequency vibrato depth, default 0, max 1.
    "_csm"  - Global composite sine-wave mode, default 0, max 1.
    "_kspl" - Global key split flag, default 0, max 1.

Amplitude and frequency parameters:

    "amp" - Operator amplitude, default 63, max 63.
    "F"   - Channel base frequency (logarithmic), default 91355, max 117824.

Operator scaling parameters:

    "fscale" - Operator frequency scaling value, default 1, max 12.
    "amod"   - Operator amplitude modulation, default 0, max 1.
    "fmod"   - Operator frequency modulation (vibrato), default 0, max 1.
    "rscale" - Operator register scaling value, default 0, max 3.
    "wave"   - Operator waveform select, default 0, max 3.

Operator envelope parameters:

    "suse"    - Operator sustain enable, default 1, max 1.
    "escale"  - Operator envelope scaling, default 0, max 1.
    "attack"  - Operator ADSR attack, default 8, max 15.
    "decay"   - Operator ADSR decay, default 8, max 15.
    "sustain" - Operator ADSR sustain, default 8, max 15.
    "release" - Operator ADSR release, default 8, max 15.

Channel configuration parameters:

    "Feedback" - Channel feedback level, default 0, max 7.
    "Network"  - Channel network setting, default 1, max 1.

The following subsections discuss these parameters in further detail.

### Global parameters

The **amplitude vibrato depth** (`_avib`) and **frequency vibrato depth** (`_fvib`) are global parameters that control the depth of the vibrato for operators that have amplitude and/or frequency vibrato enabled.  The global vibrato depth settings apply to all operators.  The following charts indicate the vibrato depths selected by the possibly values:

     Value |   _avib    |    _fvib
    =======+============+=============
       0   | +/- 1.0 dB | +/-  7 cents
       1   | +/- 4.8 dB | +/- 14 cents

The **composite sine-wave mode** (`_csm`) and **key split flag** (`_kspl`) are poorly documented elements of OPL2 state that no one seems to know how to use.  It is recommended to keep these at their default values of zero.

### Amplitude parameter

The **amplitude parameter** (`amp`) is an operator parameter that selects how much energy or loudness the operator has.  There are 64 levels of amplitude, [0, 63].  The lowest level of amplitude is not completely silent.  Amplitude in OPL2 hardware is defined in a nonlinear decibel space, so linear interpolation of amplitude parameters should produce smooth results.

### Frequency parameter

The **frequency parameter** (`F`) is a channel parameter that selects the base frequency that is performed for the channel.  OPL2 hardware supports a base frequency range of approximately 0.047 Hz to 6208.431 Hz.  In order to select the frequency, OPL2 uses an integer `f_num` and an integer `block` number, with the following formula:

    frequency = (f_num * 49716) / 2^(20 - block)

Retro automatically handles computing the `f_num` and the `block` number.

For linear interpolation in frequency domain to sound smooth, it must be performed in logarithmic space.  Retro defines a logarithmic frequency scale in range [0, 117824].  To convert from this logarithmic frequency scale to a Hz value, subtract 30488 from the integer value, divide by 10,000 in floating-point space and then take the natural exponent _e_ to the power of this floating-point value.  To convert from a Hz value to this logarithmic frequency scale, take the natural logarithm of the Hz value in floating-point space, multiply by 10,000, floor to an integer value towards negative infinity, add 30488, and clamp to the range [0, 117824].  In short:

    hz = e^((iv - 30488) / 10000.0)
    iv = max(min(floor(ln(hz) * 10000) + 30488, 117824), 0)

Following these formulas, 440 Hz (A4) would result in an integer frequency parameter of 91355 and 466.1638 (Bb4) would result in an integer frequency parameter of 91933.

### Operator scaling parameters

The actual frequency of each operator is the base frequency in Hz defined for the channel multiplied by a **frequency scaling value** (`fscale`) specific to the operator.  The valid range of values is [0, 12], which select the following frequency scaling values:

     Value |  fscale
    =======+==========
       0   |  0.5 (!)
       1   |  1.0
       2   |  2.0
       3   |  3.0
       4   |  4.0
       5   |  5.0
       6   |  6.0
       7   |  7.0
       8   |  8.0
       9   |  9.0
      10   | 10.0
      11   | 12.0 (!)
      12   | 15.0 (!)

Each operator has two flags that enable **amplitude vibrato** (`amod`) and **frequency vibrato** (`fmod`).  If enabled by the flag, the vibrato has a depth determined by the amplitude vibrato depth and frequency vibrato depth global parameters.

Operators may be programmed to scale their amplitude to a lower energy level as the frequency of the operator becomes higher.  There are four **register scaling values** (`rscale`), which indicate how much the amplitude decreases each time the frequency doubles (rises an octave).  The values [0, 3] have the following interpretations:

     Value | rscale
    =======+========
       0   | (none)
       1   | 1.5 dB
       2   | 3.0 dB
       3   | 6.0 dB

The **waveform** produced by each operator may also be changed by the `wave` parameter.  All possible waveforms are scaled derivations of a sine wave.  The four possible waveforms are:  _sine,_ _half,_ _absolute,_ and _pulse._  The sine waveform is a normal sine wave.  The half waveform replaces all negative values of the sine wave with zero.  The absolute waveform replaces all negative values of the sine wave with their absolute value.  The pulse waveform is a modification of the absolute waveform that replaces any point on a downward slope with zero.  The valid range of values is [0, 3], which have the following mapping to waveforms:

     Value |   wave
    =======+==========
       0   |   sine
       1   |   half
       2   | absolute
       3   |  pulse

### Operator envelope parameters

The amplitude of each operator is affected by an Attack-Decay-Sustain-Release (ADSR) envelope.  Each operator has a set of parameters that control the ADSR envelope.

The **sustain enable** setting (`suse`) determines whether the amplitude is sustained during the sustain phase of the envelope.  It has two values, [0, 1], where 0 disables sustain and 1 enables sustain.  Sustain enable is appropriate for instruments like organs, clarinets, and bowed violins.  Sustain enable should be turned off for effects like pizzicato, where the sound should not be sustained.

The **envelope scaling** setting (`escale`) determines whether the ADSR envelope is shortened as the frequency rises in pitch.  It has two values, [0, 1], where 0 disables envelope scaling and 1 enables it.

Finally, there are the four main envelope settings:  **attack** (`attack`), **decay** (`decay`), **sustain** (`sustain`), and **release** (`release`).  Attack, decay, and release are durations which indicate how quickly that portion of the envelope is performed.  Sustain is a scaling value in range [0.0, 1.0] that determines at what level of the attack amplitude the sustain phase holds.  A sustain scaling value of 0.5 means that the sustain level is half the amplitude of the attack, for example.  If you want sustain to be significant, you should probably set the sustain enable flag.

Each of the four main ADSR envelope settings has a range of values [0, 15].  For duration parameters, lower values are faster and higher values are longer.  For the sustain parameter, lower values are softer (closer to 0.0) and higher values are louder (closer to 1.0).  (This numeric scale is the opposite of what is used in OPL2 register values.)

### Channel configuration parameters

The **feedback level** (`Feedback`) determines how much of the first operator's output is directed back into itself.  The range of values is [0, 7], with zero being the least feedback and 7 being the most feedback.

The **network** (`Network`) determines how operators are configured within the channel.  It has two values, [0, 1].  If set to zero, both operators produce sound simultaneously (additive synthesis).  If set to one, the operator zero modulates the operator one in FM synthesis style, and the operator one is the only one that directly produces sound.

## Retro synthesis script

This section describes the format of the script given to Retro for synthesis.

Retro synthesis scripts are in Shastina format.  See [libshastina](https://github.com/canidlogic/libshastina) for a specification and a parsing library.

### Data types

Retro scripts use the following data types:

1. Null
2. Integer
3. Atom
4. Dictionary
5. Instrument
6. Graph

The null type represents a special null value indicating "no data."

Integer values are in range [-2147483647, 2147483647].

Atoms are unique codes that represent each of the different global, channel, and operator parameter names.  Parameter names are given as string literals within the Retro script, but these string literals are immediately converted to unique atom codes.

Dictionaries contain zero or more _mappings._  Each mapping maps an atom key to a value of any type, including another dictionary.  Each mapping must have a unique atom key within the dictionary.

Instruments have a parent instrument reference, and three dictionary references representing parameter overrides for channel parameters, operator zero parameters, and operator one parameters.  All references may be null.  Null dictionary references are equivalent to a reference to an empty dictionary.

Graphs use an abstract interface to allow for multiple graph object implementations.  Graph objects must indicate whether they are global or local graphs.  They must also provide a function that takes an integer time value `t` greater than or equal to zero and returns an integer parameter value in 17-bit unsigned integer range, along with another integer counting how many `t` values this parameter value will remain valid for (at least one, or the special value -1 if this value will be repeated infinitely for all following `t` values).

### Interpreter state

The Retro interpreter has an interpreter stack, and a namespace for defined variables and constants.  Values stored on the stack and in the namespace may have any of the data types defined in the preceding section.  The stack and namespace are empty at the start of interpretation.  At the end of interpretation, the stack must be empty again.

The Retro interpreter also has an _accumulator_ which is used for building up complex object definitions.  The accumulator is empty at the beginning of interpretation and must be empty at the end of interpretation.  Dictionaries and graphs can be constructed piece by piece in the accumulator and then the finished object is pushed from the accumulator onto the stack.  Only one complex object may be built in the accumulator at a time.

### Interpreter output

Running a Retro script generates a control rate setting in range [1 Hz, 1024 Hz], a set of events that are not necessarily chronologically ordered, and parameter dictionaries defining the rhythm section state.

Retro will store all these interpretation results in memory.  When the script has finished running, Retro will sequence the events it was given and produce an OPL2 output script, the format of which is described in a later section.

### Script header

The header of a retro script file looks like the following:

    %retro 1.0;
    %rate 60;

Specifically, the first Shastina entities read from the script must be:

1. `BEGIN_META`
2. `META_TOKEN` with value `retro`
3. `META_TOKEN` with version number
4. `END_META`
5. `BEGIN_META`
6. `META_TOKEN` with value `rate`
7. `META_TOKEN` with control rate
8. `END_META`

Metatoken values are case sensitive.  The version number must be exactly `1.0` for parsers targeting this version of Retro.  It is intended so that future versions can support backwards compatibility.

The control rate value is an unsigned decimal integer that must be in range [1, 1024].  It indicates the control rate in Hz.

### Entity handling

After the header, the rest of the Retro script supports all Shastina entity types except metacommands.

String entities must be double-quoted and may not have any string prefix.  The quoted string must be a case-sensitive match for one of the OPL2 parameter names defined earlier.  The entity causes an atom representing that OPL2 parameter name to be pushed onto the interpreter stack.

Numeric entities must be signed decimal integers in range [-2147483647, 2147483647].  The sequence of decimal digits is preceded by an optional sign `+` or `-`.  There is no difference between positive and negative zero.

Variable, constant, assign, and get entities are used to declare, set, and get variable and constants.  Variable and constant entities declare variables and constants, popping the initial value off the top of the stack.  Assign entities set variable values, popping the new value off the top of the stack.  (Assigning to a constant is not allowed.)  Get entities push a copy of the current variable or constant value on top of the interpreter stack.  Variables and constants share a namespace, and must be declared before being used in assign and get entities.

The names of variables and constants must be a sequence of ASCII alphanumerics and underscores with length [1, 32] where the first character is not a decimal digit.

Shastina group and array entities are also supported.  The start of a Shastina group hides everything currently on the stack until the end of the group.  At the end of the group, exactly one element must be on top of the stack.  The rest of the stack is then restored.  Array entities push an integer with the array count on top of the stack.

The supported Retro operations are described in the next section.

### Retro script operations

The syntax of Retro operations are specified with the name of the operation in the middle, the input arguments to the left of the operation, and the output results to the right of the operation.  If there are no input arguments, a hyphen is shown to the left of the operation, and if there are no output results, a hyphen is shown to the right of the operation.  Multiple arguments and results are ordered so that the rightmost argument or result is the top of the stack.

    - x [a:null]

The `x` operation pushes the special null value on top of the stack.

    - end [result:dict|graph]

The `end` operation is used to finish whichever dictionary or graph object is currently being constructed in the accumulator.  There must be something in the accumulator when this operation is issued.  The finished dictionary or graph will be pushed onto the interpreter stack and the accumulator will be cleared.

                       - dict -
    [key:atom] [val:any] m    -
               [d:dict ] cp   -

To create a new dictionary, use the `dict` operation.  The accumulator must be empty when this operation is used.  The dictionary in the accumulator starts out empty.  The `m` operation may only be used when a dictionary is in the accumulator.  It defines a new mapping from an atom key to a value of any type.  If a mapping already exists for the given atom key, it is replaced by the new atom.  The `cp` operation copies all mappings from a given dictionary into the dictionary in the accumulator.  It works as though the `m` operation were used with all mappings defined in the given dictionary.  When the dictionary in the accumulator has been completely defined, use the `end` operation to push the completed dictionary onto the interpreter stack and clear the accumulator.

    [local:int] [repeat_t:int] [repeat_r:int] graph -
    [n:int] [value:int]                       plane -
    [n:int] [start:int] [goal:int] [step:int] ramp  -

To create a new base graph, use the `graph` operation.  The accumulator must be empty when this operation is used.  `[local]` is 1 if this is a local graph, 0 if this is a global graph.  `[repeat_t]` and `[repeat_r]` are repeat offset and repeat length, respectively.  Use `plane` to append a plane block of length `[n]` cycles with constant `[value]`.  Use `ramp` to append a ramp block of length `[n]` cycles with start value `[start]`, goal value `[goal]`, and step value `[step]`.  When the graph in the accumulator has been completely defined, use the `end` operation to push the completed graph onto the interpreter stack and clear the accumulator.

    [src:graph]
    [s:int]
    [d:int]
    [p:int] [a:int] [b:int] gderive [g:graph]

Use the `gderive` operation to create a derived graph.  Unlike the `graph` operation, `gderive` does not use the accumulator, instead generating the new graph in a single operation.  `[src]` is the graph that is being derived from.  The other parameters define how values are altered, as explained earlier in "Derived graphs".

    [parent:instr|null]
    [ch:dict|null] 
    [op0:dict|null] [op1:dict|null] instr [i:instr]

The `instr` operation defines an instrument.  The input arguments define the parent instrument and three dictionaries defining channel parameter overrides, operator 0 parameter overrides, and operator 1 parameter overrides.  Any or all of the arguments may be replaced by null values.  null values are equivalent to empty dictionaries.  The `[ch]` dictionary may only have keys referring to channel parameters, and the `[op0]` and `[op1]` dictionaries may only have keys referring to operator parameters.  Dictionary values may either be integers, graphs, or null values.  Graphs may be either local or global.  Null values are equivalent to the dictionary lacking the key.

    [ch:dict|null]
    [op0:dict|null] [op1:dict|null]
    [ci:integer] pseudo -

The `pseudo` operation changes the channel and operator parameters for one of the pseudo-channels R0, R1, or R2.  The pseudo-channels are initialized with channel and operator parameter default values at the start of the script.  The `[ch]`, `[op0]`, and `[op1]` input arguments work the same way as they do for the `instr` operator, except that graphs may only be used as values if they are global graphs.  `[ci]` must be an integer in range [0, 2] that selects which of the pseudo-channels to set.  The `pseudo` operation updates the parameters that are contained within the dictionaries and leaves the other parameters at their current values.

The only state of the pseudo-channels that matters is the state that is present when the first `r` operation is given.  (If no `r` operations are present in the script, the pseudo-channels are irrelevant.)  When the first `r` operation occurs, the state of the pseudo-channels is frozen, and any attempt to use `pseudo` after `r` will result in an error.  If you want a parameter value in a pseudo-channel to change over time, use a graph object.

    [g:dict|null] global -

The `global` operation changes the global parameters.  The `[g]` dictionary, if provided, may only use keys corresponding to global parameters.  The values may be integers, graph objects, or null, with null being equivalent to no record defined for that key.  Graph objects must be global graphs.  The only global state that matters is the state that is present at the end of the script.  If you want a global parameter value to change over time, use a graph object.

    [offs:integer]
    [reserved:int] [audible:int]
    [i:instr]
    [f:int|graph|null]
    [ch:dict|null]
    [op0:dict|null] [op1:dict|null] n -

Create melodic events using the `n` operation.  `[offs]` is the offset of the start of the melodic event in cycles, `[reserved]` is the reserved duration of the event in cycles, and `[audible]` is the audible duration of the event in cycles.  `[i]` is the instrument.  `[f]` is the `F` property value for the event, or null to inherit this value.  `[ch]`, `[op0]` and `[op1]` are the parameter override dictionaries for channel parameters, operator zero parameters, and operator one parameters, with null being equivalent to an empty dictionary.  Melodic events may be defined in any order.  They do not need to be chronological.

    [offs:integer]
    [reserved:int] [audible:int]
    [p:int] r -

Create rhythm events using the `r` operation.  `[offs]`, `[reserved]`, and `[audible]` are the same as for the `n` operation.  `[p]` selects one of the percussion instruments:

     p | Instrument
    ===+============
     0 | Bass drum
     1 | Snare drum
     2 | Tom-tom
     3 | Cymbal
     4 | Hi-hat

The state of the pseudo-channels is frozen at the first `r` operation, so you should use `pseudo` before any `r` operation.

Rhythm events may be defined in any order.  They do not need to be chronological.

## OPL2 output script

This section describes the format of the hardware script file generated as output by Retro.

The hardware script file is a US-ASCII text file where line breaks may be either LF or CR+LF.  The script file is parsed line by line.  Trailing whitespace (tabs and spaces) is allowed on each line without any difference in meaning.  Leading whitespace is _not_ allowed.

The first line of the hardware script file must be:

    OPL2 [rate]

The `[rate]` is the control rate, in Hz.  It must be an integer in range [1, 1024].

Each following line must be blank, a comment, or an instruction.  Blank lines are empty or consist only of tabs and spaces.  Comment lines have an apostrophe `'` as their first character.  Both blank lines and comment lines are ignored.

There are two types of instruction lines:

    r [offset] [value]
    w [count]

The `r` instruction immediately writes `[value]` into the OPL2 hardware register at offset `[offset]`.  Both `[value]` and `[offset]` must be exactly two base-16 digits.  Letter digits may be in either uppercase or lowercase (or both).  Zero padding is used for values that only require a single base-16 digit.

The `w` instruction waits `[count]` cycles at the control rate.  The OPL2 will produce sound using the current state of the hardware registers while this instruction is waiting.  `[count]` must be an unsigned decimal integer that is in range [0, 2147483647].

At the start of interpretation, no assumptions are made about the initial state of the OPL2 hardware registers.
